"""
Project Templates for Multi-File Agent Generation

Defines the structure and templates for different types of agent projects.
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from enum import Enum


class AgentProjectType(str, Enum):
    """Types of agent projects that can be generated"""
    SIMPLE = "simple"                    # Basic single-purpose agent
    DATA_PIPELINE = "data_pipeline"      # Data processing with multiple stages
    WEB_AUTOMATION = "web_automation"    # Web scraping/automation agents
    API_INTEGRATION = "api_integration"  # External API integration agents
    MULTI_AGENT = "multi_agent"          # Multi-agent orchestration system
    WORKFLOW = "workflow"                # Workflow automation with stages
    RESEARCH = "research"                # Research and analysis agents
    CODE_ASSISTANT = "code_assistant"    # Code generation/review agents
    CUSTOM = "custom"                    # Fully custom agent project


AGENT_PROJECT_TYPES = [t.value for t in AgentProjectType]


@dataclass
class FileTemplate:
    """Template for a single file in the project"""
    path: str
    description: str
    content_template: str
    required: bool = True


@dataclass
class ProjectTemplate:
    """Complete project template with multiple files"""
    project_type: AgentProjectType
    name: str
    description: str
    files: List[FileTemplate] = field(default_factory=list)
    dependencies: List[str] = field(default_factory=list)
    env_variables: List[str] = field(default_factory=list)
    
    def get_file_paths(self) -> List[str]:
        return [f.path for f in self.files]


# =============================================================================
# BASE PROJECT TEMPLATE
# =============================================================================

BASE_MAIN_TEMPLATE = '''#!/usr/bin/env python3
"""
{project_name} - Main Entry Point

{project_description}

Generated by Aegis Agent Generator
"""

import os
import sys
import argparse
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Add project root to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from agents import create_main_agent
from config import Config
from utils.logger import setup_logger

logger = setup_logger(__name__)


def main():
    """Main entry point for the agent"""
    parser = argparse.ArgumentParser(description='{project_description}')
    parser.add_argument('task', nargs='?', help='Task to execute')
    parser.add_argument('--model', default=Config.DEFAULT_MODEL, help='LLM model to use')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode')
    parser.add_argument('--interactive', '-i', action='store_true', help='Run in interactive mode')
    
    args = parser.parse_args()
    
    if args.debug:
        Config.DEBUG = True
    
    logger.info(f"Starting {Config.PROJECT_NAME}...")
    
    try:
        agent = create_main_agent(model=args.model)
        
        if args.interactive:
            run_interactive(agent)
        elif args.task:
            run_task(agent, args.task)
        else:
            parser.print_help()
            
    except KeyboardInterrupt:
        logger.info("Interrupted by user")
    except Exception as e:
        logger.error(f"Error: {{e}}")
        if Config.DEBUG:
            raise


def run_task(agent, task: str):
    """Execute a single task"""
    from aegis import Aegis
    
    aegis = Aegis()
    messages = [{{"role": "user", "content": task}}]
    
    response = aegis.run(
        agent=agent,
        messages=messages,
        debug=Config.DEBUG
    )
    
    # Extract and print result
    for msg in reversed(response.messages):
        if msg.get("role") == "assistant" and msg.get("content"):
            print(msg["content"])
            break


def run_interactive(agent):
    """Run agent in interactive mode"""
    from aegis import Aegis
    
    aegis = Aegis()
    messages = []
    
    print(f"\\n{Config.PROJECT_NAME} - Interactive Mode")
    print("Type 'exit' or 'quit' to exit\\n")
    
    while True:
        try:
            user_input = input("You: ").strip()
            
            if user_input.lower() in ['exit', 'quit']:
                break
            
            if not user_input:
                continue
            
            messages.append({{"role": "user", "content": user_input}})
            
            response = aegis.run(
                agent=agent,
                messages=messages,
                debug=Config.DEBUG
            )
            
            # Get assistant response
            for msg in response.messages:
                if msg.get("role") == "assistant" and msg.get("content"):
                    print(f"\\nAgent: {{msg['content']}}\\n")
                    messages.append(msg)
                    
        except KeyboardInterrupt:
            break
    
    print("\\nGoodbye!")


if __name__ == "__main__":
    main()
'''

BASE_CONFIG_TEMPLATE = '''"""
Configuration for {project_name}
"""

import os
from typing import Optional


class Config:
    """Project configuration"""
    
    # Project Info
    PROJECT_NAME = "{project_name}"
    VERSION = "1.0.0"
    
    # Model Configuration
    DEFAULT_MODEL = os.getenv("DEFAULT_MODEL", "{default_model}")
    
    # API Keys (loaded from environment)
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY")
    GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
    
    # Debug Mode
    DEBUG = os.getenv("DEBUG", "false").lower() == "true"
    
    # Paths
    PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
    DATA_DIR = os.path.join(PROJECT_ROOT, "data")
    OUTPUT_DIR = os.path.join(PROJECT_ROOT, "output")
    
    # Custom Configuration
{custom_config}

    @classmethod
    def ensure_dirs(cls):
        """Ensure required directories exist"""
        os.makedirs(cls.DATA_DIR, exist_ok=True)
        os.makedirs(cls.OUTPUT_DIR, exist_ok=True)
'''

BASE_AGENTS_INIT_TEMPLATE = '''"""
Agent definitions for {project_name}
"""

from agents.main_agent import create_main_agent
{additional_imports}

__all__ = [
    'create_main_agent',
{additional_exports}
]
'''

BASE_MAIN_AGENT_TEMPLATE = '''"""
Main Agent for {project_name}

{agent_description}
"""

from aegis.types import Agent
from aegis.tools.inner import case_resolved, case_not_resolved
{tool_imports}


def get_instructions(context_variables: dict = None) -> str:
    """Dynamic instructions based on context"""
    context_variables = context_variables or {{}}
    
    base_instructions = """{instructions}"""
    
    # Add context-specific instructions
    if context_variables.get("task_type"):
        base_instructions += f"\\n\\nCurrent task type: {{context_variables['task_type']}}"
    
    return base_instructions


def create_main_agent(model: str = None) -> Agent:
    """Create the main agent instance"""
    from config import Config
    
    model = model or Config.DEFAULT_MODEL
    
    tools = [
{tool_list}
        case_resolved,
        case_not_resolved,
    ]
    
    return Agent(
        name="{agent_name}",
        model=model,
        instructions=get_instructions,
        functions=tools,
        tool_choice="required",
        parallel_tool_calls={parallel_tools},
        metadata={{
            "project": Config.PROJECT_NAME,
            "version": Config.VERSION
        }}
    )
'''

BASE_TOOLS_INIT_TEMPLATE = '''"""
Custom tools for {project_name}
"""

{tool_imports}

__all__ = [
{tool_exports}
]
'''

BASE_CUSTOM_TOOL_TEMPLATE = '''"""
{tool_name} - Custom tool for {project_name}
"""

from aegis.registry import register_tool
from typing import Optional, Dict, Any
import json


@register_tool("{tool_function_name}")
def {tool_function_name}({parameters}) -> str:
    """
    {tool_description}
    
    Args:
{args_docstring}
    
    Returns:
        {return_description}
    """
    try:
{tool_implementation}
    except Exception as e:
        return f"[ERROR] {tool_name} failed: {{str(e)}}"
'''

BASE_UTILS_INIT_TEMPLATE = '''"""
Utility modules for {project_name}
"""

from utils.logger import setup_logger
from utils.helpers import *

__all__ = ['setup_logger']
'''

BASE_LOGGER_TEMPLATE = '''"""
Logging configuration for {project_name}
"""

import logging
import sys
from typing import Optional


def setup_logger(name: str, level: Optional[int] = None) -> logging.Logger:
    """Set up a logger with console output"""
    from config import Config
    
    logger = logging.getLogger(name)
    
    if level is None:
        level = logging.DEBUG if Config.DEBUG else logging.INFO
    
    logger.setLevel(level)
    
    if not logger.handlers:
        handler = logging.StreamHandler(sys.stdout)
        handler.setLevel(level)
        
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    
    return logger
'''

BASE_HELPERS_TEMPLATE = '''"""
Helper functions for {project_name}
"""

import json
import os
from typing import Any, Dict, List, Optional


def load_json(filepath: str) -> Dict[str, Any]:
    """Load JSON file"""
    with open(filepath, 'r', encoding='utf-8') as f:
        return json.load(f)


def save_json(data: Any, filepath: str, indent: int = 2):
    """Save data to JSON file"""
    os.makedirs(os.path.dirname(filepath), exist_ok=True)
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=indent, ensure_ascii=False)


def read_file(filepath: str) -> str:
    """Read text file"""
    with open(filepath, 'r', encoding='utf-8') as f:
        return f.read()


def write_file(content: str, filepath: str):
    """Write text file"""
    os.makedirs(os.path.dirname(filepath), exist_ok=True)
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(content)


def ensure_dir(path: str):
    """Ensure directory exists"""
    os.makedirs(path, exist_ok=True)

{additional_helpers}
'''

BASE_REQUIREMENTS_TEMPLATE = '''# {project_name} Dependencies

# Core
aegis-service>=0.1.0
litellm>=1.0.0
python-dotenv>=1.0.0

# Additional dependencies
{additional_deps}
'''

BASE_ENV_TEMPLATE = '''# {project_name} Environment Configuration

# Model Configuration
DEFAULT_MODEL={default_model}

# API Keys (uncomment and fill in as needed)
# OPENAI_API_KEY=your-openai-key
# ANTHROPIC_API_KEY=your-anthropic-key
# GEMINI_API_KEY=your-gemini-key

# Debug Mode
DEBUG=false

{additional_env}
'''

BASE_README_TEMPLATE = '''# {project_name}

{project_description}

## Generated by Aegis Agent Generator

This is a multi-file agent project that can be run standalone or integrated into larger systems.

## Project Structure

```
{project_name}/
├── main.py              # Entry point
├── config.py            # Configuration
├── agents/              # Agent definitions
│   ├── __init__.py
│   └── main_agent.py
├── tools/               # Custom tools
│   ├── __init__.py
│   └── *.py
├── utils/               # Utilities
│   ├── __init__.py
│   ├── logger.py
│   └── helpers.py
├── data/                # Data files
├── output/              # Output files
├── requirements.txt     # Dependencies
├── .env.example         # Environment template
└── README.md           # This file
```

## Quick Start

1. **Install Dependencies**
   ```bash
   pip install -r requirements.txt
   ```

2. **Configure Environment**
   ```bash
   cp .env.example .env
   # Edit .env with your API keys
   ```

3. **Run the Agent**
   ```bash
   # Single task
   python main.py "your task here"
   
   # Interactive mode
   python main.py -i
   
   # With specific model
   python main.py --model gpt-4o "your task"
   ```

## Features

{features_list}

## Tools Available

{tools_list}

## Configuration

Edit `config.py` or use environment variables to configure:

- `DEFAULT_MODEL`: LLM model to use
- `DEBUG`: Enable debug logging
- API keys for various providers

## License

MIT License
'''

# =============================================================================
# SPECIALIZED TEMPLATES
# =============================================================================

MULTI_AGENT_ORCHESTRATOR_TEMPLATE = '''"""
Multi-Agent Orchestrator for {project_name}

Coordinates multiple specialized agents for complex tasks.
"""

from typing import Dict, List, Optional, Any
from aegis.types import Agent
from aegis import Aegis
from utils.logger import setup_logger

logger = setup_logger(__name__)


class AgentOrchestrator:
    """Orchestrates multiple agents for complex workflows"""
    
    def __init__(self, agents: Dict[str, Agent]):
        """
        Initialize orchestrator with available agents.
        
        Args:
            agents: Dictionary of agent_name -> Agent instance
        """
        self.agents = agents
        self.aegis = Aegis()
        self.context = {{}}
    
    def route_task(self, task: str) -> str:
        """
        Route a task to the appropriate agent.
        
        Args:
            task: The task description
            
        Returns:
            Agent name best suited for the task
        """
        # Simple keyword-based routing (can be enhanced with LLM)
        task_lower = task.lower()
        
{routing_logic}
        
        return "main"  # Default agent
    
    def execute(self, task: str, agent_name: str = None) -> Dict[str, Any]:
        """
        Execute a task with the specified or auto-routed agent.
        
        Args:
            task: Task to execute
            agent_name: Optional specific agent to use
            
        Returns:
            Execution results
        """
        if agent_name is None:
            agent_name = self.route_task(task)
        
        if agent_name not in self.agents:
            return {{"error": f"Agent '{{agent_name}}' not found"}}
        
        agent = self.agents[agent_name]
        logger.info(f"Routing task to agent: {{agent_name}}")
        
        messages = [{{"role": "user", "content": task}}]
        
        response = self.aegis.run(
            agent=agent,
            messages=messages,
            context_variables=self.context
        )
        
        # Extract result
        result = None
        for msg in reversed(response.messages):
            if msg.get("role") == "assistant" and msg.get("content"):
                result = msg["content"]
                break
        
        return {{
            "agent": agent_name,
            "result": result,
            "messages": response.messages
        }}
    
    def execute_workflow(self, tasks: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Execute a sequence of tasks as a workflow.
        
        Args:
            tasks: List of task configurations
            
        Returns:
            Results from each task
        """
        results = []
        
        for task_config in tasks:
            task = task_config.get("task")
            agent = task_config.get("agent")
            depends_on = task_config.get("depends_on")
            
            # Add dependency results to context
            if depends_on:
                for dep_idx in depends_on:
                    if dep_idx < len(results):
                        self.context[f"step_{{dep_idx}}_result"] = results[dep_idx].get("result")
            
            result = self.execute(task, agent)
            results.append(result)
        
        return results
'''

DATA_PIPELINE_TEMPLATE = '''"""
Data Pipeline for {project_name}

Handles data extraction, transformation, and loading.
"""

from typing import Dict, List, Any, Optional
from dataclasses import dataclass
import json
import os

from utils.logger import setup_logger

logger = setup_logger(__name__)


@dataclass
class PipelineStage:
    """A single stage in the data pipeline"""
    name: str
    handler: callable
    config: Dict[str, Any] = None


class DataPipeline:
    """Data processing pipeline"""
    
    def __init__(self):
        self.stages: List[PipelineStage] = []
        self.results: Dict[str, Any] = {{}}
    
    def add_stage(self, name: str, handler: callable, config: Dict[str, Any] = None):
        """Add a processing stage"""
        self.stages.append(PipelineStage(name, handler, config or {{}}))
    
    def run(self, input_data: Any) -> Dict[str, Any]:
        """Run the pipeline"""
        current_data = input_data
        
        for stage in self.stages:
            logger.info(f"Running stage: {{stage.name}}")
            try:
                current_data = stage.handler(current_data, **stage.config)
                self.results[stage.name] = {{
                    "status": "success",
                    "output": current_data
                }}
            except Exception as e:
                logger.error(f"Stage {{stage.name}} failed: {{e}}")
                self.results[stage.name] = {{
                    "status": "error",
                    "error": str(e)
                }}
                raise
        
        return {{
            "final_output": current_data,
            "stages": self.results
        }}


# Pre-built stage handlers
def extract_json(data: Any, filepath: str = None, **kwargs) -> Dict:
    """Extract data from JSON source"""
    if filepath:
        with open(filepath, 'r') as f:
            return json.load(f)
    return data


def transform_map(data: List[Dict], mapping: Dict[str, str], **kwargs) -> List[Dict]:
    """Transform data using field mapping"""
    return [
        {{new_key: item.get(old_key) for old_key, new_key in mapping.items()}}
        for item in data
    ]


def filter_data(data: List[Dict], condition: callable, **kwargs) -> List[Dict]:
    """Filter data based on condition"""
    return [item for item in data if condition(item)]


def save_output(data: Any, filepath: str, format: str = "json", **kwargs) -> Any:
    """Save data to file"""
    os.makedirs(os.path.dirname(filepath), exist_ok=True)
    
    if format == "json":
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2)
    
    return data
'''


def get_template_for_type(project_type: AgentProjectType) -> ProjectTemplate:
    """Get the project template for a given type"""
    
    templates = {
        AgentProjectType.SIMPLE: ProjectTemplate(
            project_type=AgentProjectType.SIMPLE,
            name="Simple Agent",
            description="Basic single-purpose agent project",
            dependencies=["litellm", "python-dotenv"],
            env_variables=["DEFAULT_MODEL", "OPENAI_API_KEY"]
        ),
        AgentProjectType.MULTI_AGENT: ProjectTemplate(
            project_type=AgentProjectType.MULTI_AGENT,
            name="Multi-Agent System",
            description="Multi-agent orchestration with specialized agents",
            dependencies=["litellm", "python-dotenv", "pydantic"],
            env_variables=["DEFAULT_MODEL", "OPENAI_API_KEY"]
        ),
        AgentProjectType.DATA_PIPELINE: ProjectTemplate(
            project_type=AgentProjectType.DATA_PIPELINE,
            name="Data Pipeline Agent",
            description="Data processing pipeline with extraction, transformation, and loading",
            dependencies=["litellm", "python-dotenv", "pandas"],
            env_variables=["DEFAULT_MODEL", "OPENAI_API_KEY"]
        ),
        AgentProjectType.WEB_AUTOMATION: ProjectTemplate(
            project_type=AgentProjectType.WEB_AUTOMATION,
            name="Web Automation Agent",
            description="Web scraping and browser automation agent",
            dependencies=["litellm", "python-dotenv", "beautifulsoup4", "requests", "selenium"],
            env_variables=["DEFAULT_MODEL", "OPENAI_API_KEY"]
        ),
        AgentProjectType.API_INTEGRATION: ProjectTemplate(
            project_type=AgentProjectType.API_INTEGRATION,
            name="API Integration Agent",
            description="REST API integration and orchestration agent",
            dependencies=["litellm", "python-dotenv", "requests", "httpx"],
            env_variables=["DEFAULT_MODEL", "OPENAI_API_KEY"]
        ),
        AgentProjectType.RESEARCH: ProjectTemplate(
            project_type=AgentProjectType.RESEARCH,
            name="Research Agent",
            description="Research and analysis agent with web search capabilities",
            dependencies=["litellm", "python-dotenv", "requests", "beautifulsoup4"],
            env_variables=["DEFAULT_MODEL", "OPENAI_API_KEY", "SERPER_API_KEY"]
        ),
        AgentProjectType.CODE_ASSISTANT: ProjectTemplate(
            project_type=AgentProjectType.CODE_ASSISTANT,
            name="Code Assistant Agent",
            description="Code generation, review, and refactoring agent",
            dependencies=["litellm", "python-dotenv", "pygments", "ast-grep"],
            env_variables=["DEFAULT_MODEL", "OPENAI_API_KEY"]
        ),
        AgentProjectType.WORKFLOW: ProjectTemplate(
            project_type=AgentProjectType.WORKFLOW,
            name="Workflow Agent",
            description="Workflow automation with stages and conditions",
            dependencies=["litellm", "python-dotenv", "pydantic"],
            env_variables=["DEFAULT_MODEL", "OPENAI_API_KEY"]
        ),
        AgentProjectType.CUSTOM: ProjectTemplate(
            project_type=AgentProjectType.CUSTOM,
            name="Custom Agent",
            description="Fully customizable agent project",
            dependencies=["litellm", "python-dotenv"],
            env_variables=["DEFAULT_MODEL", "OPENAI_API_KEY"]
        ),
    }
    
    return templates.get(project_type, templates[AgentProjectType.SIMPLE])
